# ADR 002: Plugin System via Python Entry Points

**Date**: 2026-02-02
**Status**: Accepted

## Context

Проект `rag4code` строится как модульная система ("LEGO-архитектура"), где ключевые компоненты (Vector DB, Embedder, Chunker) должны быть легко заменяемыми.

Нам необходимо выбрать механизм для:
1.  **Обнаружения (Discovery)**: Как ядро (`rag4code-core`) узнает, какие плагины доступны?
2.  **Загрузки (Loading)**: Как ядро получает доступ к коду плагина?
3.  **Инициализации (Initialization)**: Как создаются экземпляры классов плагинов?

Дополнительное требование: Интеграция с **HPM (Hyper Package Manager)**, который управляет составом зависимостей (`pyproject.toml`) и режимами Dev/Prod.

## Alternatives Considered

### 1. Явная регистрация (Manual Registry)
Плагины должны импортировать `Factory` из ядра и вызывать `Factory.register()`.
*   **Плюсы**: Простота реализации.
*   **Минусы**: Сильная связность (Plugin зависит от Core). Проблема "курицы и яйца": код плагина должен быть импортирован до того, как он сможет зарегистрироваться. Это требует "магических" импортов всех модулей при старте.

### 2. Конфигурация путей (String Path Config)
Конфиг содержит полный путь к классу: `vector_db: "my_plugin.module:MyClass"`.
*   **Плюсы**: Полная гибкость. Не требует регистрации.
*   **Минусы**: Конфиг становится хрупким. При рефакторинге (переименовании класса) конфиг ломается. Пользователю нужно знать внутреннюю структуру пакета.

### 3. Python Entry Points (Standard Mechanism)
Использование стандартного механизма `[project.entry-points]` в `pyproject.toml` плагина.
*   **Плюсы**:
    *   **Стандарт**: Нативный механизм Python.
    *   **Decoupling**: Ядро и плагин не знают друг о друге (только общий интерфейс).
    *   **Lazy Loading**: Ядро может получить список доступных плагинов без импорта их кода.
    *   **HPM Synergy**: HPM гарантирует установку пакета, а Entry Points обеспечивают его обнаружение.

## Decision

Мы выбираем **Python Entry Points** как основной механизм обнаружения плагинов, в сочетании с **Фабрикой** для их инициализации.

### Детали реализации

1.  **Интерфейсы**: Core определяет абстрактные классы (например, `VectorDBInterface`).
2.  **Плагины**:
    *   Реализуют интерфейс.
    *   Объявляют entry point в своем `pyproject.toml`:
        ```toml
        [project.entry-points."rag4code.vector_db"]
        qdrant = "rag4code_qdrant.adapter:QdrantAdapter"
        ```
3.  **HPM**: Управляет установкой пакета плагина в окружение.
4.  **Ядро**:
    *   Использует `importlib.metadata.entry_points(group='rag4code.vector_db')` для поиска.
    *   Загружает класс по имени (`qdrant`).
    *   Инициализирует его, передавая конфигурацию.

## Consequences

### Positive
*   Чистая архитектура: Плагины полностью изолированы.
*   Удобство для пользователя: В конфиге достаточно указать `type: qdrant`, а не длинный путь к классу.
*   Поддержка экосистемы: Любой сторонний разработчик может создать плагин, просто добавив entry point.

### Negative
*   Необходимость соблюдения контрактов имен групп entry points (`rag4code.vector_db`, `rag4code.embedder`).