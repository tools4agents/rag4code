# Python Entry Points

## Что это такое?

**Entry Points** (Точки входа) — это стандартный механизм в экосистеме Python, позволяющий пакетам "объявлять" о своих возможностях (плагинах) и находить друг друга без явного импорта кода.

Этот механизм решает главную проблему паттерна "Фабрика с регистрацией": необходимость знать, какие модули импортировать, чтобы они успели зарегистрироваться.

## Как это работает?

1.  **Install Time**: Когда вы устанавливаете пакет (через `pip`, `uv` и т.д.), установщик читает файл `pyproject.toml` (или `setup.py`) и находит секцию `entry-points`.
2.  **Metadata**: Информация о точках входа записывается в специальную директорию с метаданными (`.dist-info/entry_points.txt`) внутри вашего `site-packages`.
3.  **Run Time**: Ваше приложение может спросить у Python: "Дай мне список всех установленных пакетов, которые реализуют интерфейс X". Python сканирует метаданные (это очень быстро) и возвращает список, не загружая сам код плагинов.

## Пример реализации

### 1. Сторона Плагина (Provider)

Предположим, мы делаем плагин `rag4code-qdrant`. В его `pyproject.toml` мы пишем:

```toml
[project.entry-points."rag4code.vector_db"]
# Имя = Путь к классу
qdrant = "rag4code_qdrant.adapter:QdrantAdapter"
```

Это говорит: "Я реализую интерфейс `rag4code.vector_db` под именем `qdrant`. Мой код лежит в `rag4code_qdrant.adapter`, класс `QdrantAdapter`".

### 2. Сторона Ядра (Consumer)

Ядро системы (`rag4code-core`) использует стандартную библиотеку `importlib.metadata` (Python 3.8+) для поиска плагинов:

```python
from importlib.metadata import entry_points

def load_vector_db(name: str):
    # 1. Получаем все зарегистрированные плагины группы 'rag4code.vector_db'
    # Примечание: Синтаксис немного отличается в разных версиях Python, 
    # ниже пример для Python 3.10+
    discovered_plugins = entry_points(group='rag4code.vector_db')
    
    # 2. Ищем нужный по имени
    for plugin in discovered_plugins:
        if plugin.name == name:
            # 3. Загружаем код (import происходит только здесь!)
            plugin_class = plugin.load()
            return plugin_class
            
    raise ValueError(f"Plugin {name} not found")
```

## Преимущества

1.  **Lazy Loading**: Код плагина не импортируется, пока он реально не понадобится. Это ускоряет старт приложения.
2.  **Decoupling**: Ядро не знает о существовании плагинов. Плагины не знают о ядре (кроме соблюдения интерфейса).
3.  **Standard**: Это нативный механизм Python, поддерживаемый всеми инструментами (`pip`, `uv`, `poetry`).
4.  **No Magic Imports**: Не нужно писать код, который сканирует папки и импортирует все файлы подряд, надеясь найти там плагины.

## Связь с HPM

В контексте **HPM (Hyper Package Manager)**:
*   HPM гарантирует, что нужный пакет-плагин **установлен** в окружение (через `uv add`).
*   Entry Points позволяют Ядру **найти** этот пакет автоматически.

Это идеальный тандем: HPM управляет наличием пакетов в uv-окружении, Entry Points управляют связыванием кода в рантайме.